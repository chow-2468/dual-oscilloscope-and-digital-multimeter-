/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2025-09-02

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "stm32f429i_discovery.h"
#include "defines.h"
#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <string.h>

#include "UIdesign.h"
#include "touchScreen.h"
#include "oscilloscope.h"
#include "fsmc_nand.h"
#include "dmm.h"
#include "dht22.h"

/* Private macro */
#define MODE_OSCILLOSCOPE 1
#define MODE_DMM 2
/* Private variables */
volatile uint8_t refresh_screen = 0;
volatile uint16_t oscilloscope_data_buffer[480];
volatile uint16_t dmm_buffer[2];
volatile uint8_t get_temp = 1;
volatile float temp_value = 0;

/* Private function prototypes */
void osc();
void drawOSCchannel(int, uint16_t, uint16_t*, uint16_t*, uint16_t);
void drawMatricesUI();
float osci_freq(uint16_t [], uint16_t, uint8_t, int, int, uint8_t, int*, int*);
float osci_duty(uint16_t [], uint16_t, uint8_t, int, int, int, int);
void displayMatricesValues(uint16_t [], uint16_t, uint8_t, uint8_t, uint8_t);
void save_waveform_to_nand(uint8_t*);
void recall_waveform_from_nand(uint16_t *);
void dmm();
void screen_timer(void);
void floatToStringEXT(char*, float, int);
void displayValue(float, int, char*, char*);
void float_to_str(float, char*, int);

/* Private functions */




/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{
  int i = 0;
  SystemInit();
  TM_ILI9341_Init();
  TM_STMPE811_Init();
  dmm_init();
  TM_ILI9341_Rotate(TM_ILI9341_Orientation_Landscape_2);
  touchData.orientation = TM_STMPE811_Orientation_Landscape_2;
  display_splash_screen();
  delay_ms(3000);


  while (1){
	  i++;
	  menuButtonInit();
	  drawMenuUI();
	  int mode = -1;

	  while (mode != MODE_OSCILLOSCOPE && mode != MODE_DMM) {
		  mode = menuTS();
	  }
	  switch (mode) {
		  case MODE_OSCILLOSCOPE:
			  osc();
			  break;

		  case MODE_DMM:
			  dmm();
			  break;
		  default:
			  break;// loop back to wait input
	   }

  }

}

void osc() {
    oscButtonInit();
    drawOscilloscopeUI(); // Draw the Oscilloscope UI

    oscilloscope_init(oscilloscope_data_buffer, 480);

    adc_timer(MODE_500ms_DIV);
    TM_ILI9341_Puts(170, 5, "500ms/div", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_BLUE);

    FMC_NAND_Init();
    screen_timer();
    TIM_Cmd(TIM4, ENABLE); // activate timer
    TIM_Cmd(TIM3, ENABLE);

    static uint16_t arranged_buffer[480];
    static uint16_t read_spi_buffer[480];

    uint16_t buffer[480];
    static uint16_t old_y_ch1[240] = {0};
    static uint16_t old_y_ch2[240] = {0};
    int decimation_factor = 5; // for graph display factor
    int oscMode = 9;
    int ch1 = 0; // off ch1
    int ch2 = 0; // off ch2
    int adc_rate = 500; // 500ms/div
    int show_matrices = 0;
    int is_recall=0;
    while (oscMode != 0) {
        // Read the touch input
        oscMode = oscTS();

        if (oscMode > 0 && oscMode < 8) { // check touch screen input value
        	// Clear the old waveforms
        	for (int x = 1; x < 240; x++) {
        	    if (ch1) {
        	        // Clear the horizontal and vertical segments of CH1's waveform
        	        TM_ILI9341_DrawLine(x - 1, old_y_ch1[x - 1], x, old_y_ch1[x - 1], ILI9341_COLOR_BLACK);
        	        TM_ILI9341_DrawLine(x, old_y_ch1[x - 1], x, old_y_ch1[x], ILI9341_COLOR_BLACK);
        	    }
        	    if (ch2) {
        	        // Clear the horizontal and vertical segments of CH2's waveform
        	        TM_ILI9341_DrawLine(x - 1, old_y_ch2[x - 1], x, old_y_ch2[x - 1], ILI9341_COLOR_BLACK);
        	        TM_ILI9341_DrawLine(x, old_y_ch2[x - 1], x, old_y_ch2[x], ILI9341_COLOR_BLACK);
        	    }
        	}
            drawAxis();

            switch (oscMode) {
                case 1: // CH 1 button was pressed
                    ch1 = ~ch1;
                    if (!show_matrices){ //prevent overwrite matrices display
                        uint16_t colorCH1 = ch1 ? ILI9341_COLOR_YELLOW:ILI9341_COLOR_SLATE_BLUE; // button colour
                        uint16_t colorTxt = ch1 ? ILI9341_COLOR_BLACK :ILI9341_COLOR_WHITE;
                        TM_ILI9341_DrawFilledRectangle(245, 72, 315, 117, colorCH1);
                        TM_ILI9341_DrawRectangle(245, 72, 315, 117, ILI9341_COLOR_WHITE);
                        TM_ILI9341_Puts(258, 85, "CH 1", &TM_Font_11x18, colorTxt, colorCH1);
                    };

                    break;

                case 2: // CH 2 button was pressed
                    ch2 = ~ch2;
                    if (!show_matrices){
						uint16_t colorCH2 = ch2 ? ILI9341_COLOR_ORANGE:ILI9341_COLOR_SLATE_BLUE;
						TM_ILI9341_DrawFilledRectangle(245, 124, 315, 169, colorCH2);
						TM_ILI9341_DrawRectangle(245, 124, 315, 169, ILI9341_COLOR_WHITE);
						TM_ILI9341_Puts(258, 137, "CH 2", &TM_Font_11x18, ILI9341_COLOR_WHITE, colorCH2);
                    };
                    break;

                case 3:
                	show_matrices = ~show_matrices;
                	if (show_matrices){
                		drawMatricesUI();
						TM_ILI9341_DrawFilledRectangle(245, 180, 315, 221, ILI9341_COLOR_MAGENTA);
						TM_ILI9341_DrawRectangle(245, 180, 315, 221, ILI9341_COLOR_WHITE);
						TM_ILI9341_Puts(253, 193, "Close", &TM_Font_11x18, ILI9341_COLOR_WHITE, ILI9341_COLOR_MAGENTA);
                	}
					else {// erase the draw right menu bar button
                		drawRightMenuBar(ch1,ch2);
                	}


                    break;

                case 4: // change division
                    switch (decimation_factor){
                    case 1:// switch to next division
                        adc_timer(MODE_200ms_DIV);
                        adc_rate = 200;
                        TM_ILI9341_Puts(170, 5, "200ms/div", &TM_Font_7x10, ILI9341_COLOR_BLACK, ILI9341_COLOR_CYAN);
                        decimation_factor = 2;
                        break;
                    case 2:
                    	adc_timer(MODE_500ms_DIV);
                        adc_rate = 500;
                        TM_ILI9341_Puts(170, 5, "500ms/div", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_SLATE_BLUE);
                        decimation_factor = 5;
                        break;
                    case 5:
						adc_timer(MODE_1000ms_DIV);
						adc_rate = 1000;
						TM_ILI9341_Puts(170, 5, "   1s/div", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_MAGENTA);
						decimation_factor = 10;
						break;
                    case 10:
                        adc_timer(MODE_100ms_DIV);
                        adc_rate = 100;
                        TM_ILI9341_Puts(170, 5, "100ms/div", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_MOSS_GREEN);
                        decimation_factor = 1;
                        break;
                    }
                    break;


                case 5: // STORE button was pressed
                	create_linear_snapshot(oscilloscope_data_buffer,arranged_buffer,480);
                	save_waveform_to_nand((uint8_t*)arranged_buffer);
					break;

                case 6: // RESTORE button was pressed
                	is_recall = !is_recall;
                	recall_waveform_from_nand(read_spi_buffer);
//                    plotStaticWaveform(read_spi_buffer, ch1, ch2, ILI9341_COLOR_YELLOW, ILI9341_COLOR_ORANGE);
                    // cancel button
                    if(is_recall){
                    	TM_ILI9341_DrawFilledRectangle(164, 188, 239, 220, ILI9341_COLOR_RED);
                    	TM_ILI9341_DrawRectangle(164, 188, 239, 220, ILI9341_COLOR_WHITE);
                    	TM_ILI9341_Puts(180-2*5, 200-6, "Cancel", &TM_Font_11x18, ILI9341_COLOR_WHITE, ILI9341_COLOR_RED);
                    	drawGraphUI(); // erase the plotted graph
                    }
                    else{
                    	TM_ILI9341_DrawFilledRectangle(164, 188, 239, 220, ILI9341_COLOR_MOSS_GREEN);
                    	TM_ILI9341_DrawRectangle(164, 188, 239, 220, ILI9341_COLOR_WHITE);
                    	TM_ILI9341_Puts(177, 200, "Restore", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_MOSS_GREEN);
                    	drawGraphUI(); // erase the plotted graph

                    }
					break;

                default:
                    // Do nothing for invalid presses
                    break;
            }
            if (ch1) {//if changed channel, print displayed text
    			TM_ILI9341_Puts(110, 228, "CH1: 1V/div", &TM_Font_7x10, ILI9341_COLOR_YELLOW, ILI9341_COLOR_DARK_BLUE);
    		} else {
    			TM_ILI9341_Puts(110, 228, "           ", &TM_Font_7x10, ILI9341_COLOR_DARK_BLUE, ILI9341_COLOR_DARK_BLUE);
    		}
    		if (ch2) {
    			TM_ILI9341_Puts(220, 228, "CH2: 1V/div", &TM_Font_7x10, ILI9341_COLOR_ORANGE, ILI9341_COLOR_DARK_BLUE);
    		} else {
    			TM_ILI9341_Puts(220, 228, "           ", &TM_Font_7x10, ILI9341_COLOR_DARK_BLUE, ILI9341_COLOR_DARK_BLUE);
    		}
        }

        if(is_recall)
        	memcpy(buffer, read_spi_buffer, 480 * sizeof(uint16_t));
        else
        	memcpy(buffer, oscilloscope_data_buffer, 480 * sizeof(uint16_t));


    	if (show_matrices){// if show_matrices = true, refresh to show matrices
    		displayMatricesValues(buffer, 480, adc_rate, ch1, ch2);
    	}


        if (refresh_screen) {
            refresh_screen = 0; // Reset the flag

            // Clear the old waveforms
            if(ch1 ||ch2){// clear if only screen is turned on
				for (int x = 1; x < 240; x++) {
					if (ch1) {
						// Clear the horizontal and vertical segments of CH1's waveform
						TM_ILI9341_DrawLine(x - 1, old_y_ch1[x - 1], x, old_y_ch1[x - 1], ILI9341_COLOR_BLACK);
						TM_ILI9341_DrawLine(x, old_y_ch1[x - 1], x, old_y_ch1[x], ILI9341_COLOR_BLACK);
					}
					if (ch2) {
						// Clear the horizontal and vertical segments of CH2's waveform
						TM_ILI9341_DrawLine(x - 1, old_y_ch2[x - 1], x, old_y_ch2[x - 1], ILI9341_COLOR_BLACK);
						TM_ILI9341_DrawLine(x, old_y_ch2[x - 1], x, old_y_ch2[x], ILI9341_COLOR_BLACK);
					}
				}
				drawAxis();
            }



            // Find the index of the sample pair the DMA is currently writing to
            uint16_t dma_write_ptr = 480 - DMA_GetCurrDataCounter(DMA2_Stream0);
            uint16_t current_pair_start_idx = dma_write_ptr & 0xFFFE;
            uint16_t read_start_idx = (current_pair_start_idx + 2) % 480;
            uint16_t start_idx = is_recall? 0: read_start_idx;

            memset(old_y_ch1, 0, sizeof(old_y_ch1));
            memset(old_y_ch2, 0, sizeof(old_y_ch2));

            if (ch1) {
                // --- CH1 ---
                drawOSCchannel(1, start_idx, buffer, old_y_ch1, ILI9341_COLOR_YELLOW);
            }

            if (ch2) {
                // --- CH2 ---
                drawOSCchannel(2, start_idx, buffer, old_y_ch2, ILI9341_COLOR_ORANGE);

            }
        }
    }
}

void drawOSCchannel(
    int channel,
    uint16_t read_start_idx,
    uint16_t* oscilloscope_data_buffer,
    uint16_t* old_y,
    uint16_t line_color) {

    uint16_t current_y, prev_y;
    int data_offset = (channel == 1) ? 0 : 1; // 0 for CH1, 1 for CH2

    // --- Handle the first point as a single pixel ---
    uint16_t first_idx = read_start_idx + data_offset;
    uint16_t adc_first = oscilloscope_data_buffer[first_idx];
    float voltage_first = (float)adc_first * (3.3f / 4095.0f);
    prev_y = 180 - (voltage_first * 40.0f);
    if (prev_y < 20) prev_y = 20;
    if (prev_y > 180) prev_y = 180;
    TM_ILI9341_DrawPixel(0, prev_y, line_color); // Draw the first point at x=0
    old_y[0] = prev_y; // Store the first y-coordinate

    // --- Loop through the remaining points and draw stepped lines ---
    for (int x = 1; x < 240; x++) {
        uint16_t current_idx = ((read_start_idx) + (x) * 2 + data_offset) % 480;
        uint16_t adc_current = oscilloscope_data_buffer[current_idx];

        float voltage_current = (float)adc_current * (3.3f / 4095.0f);
        current_y = 180 - (voltage_current * 40.0f);

        if (current_y < 20) current_y = 20; //min graph ui
        if (current_y > 180) current_y = 180; // max graph ui

        // Get the previous y-coordinate
        prev_y = old_y[x - 1];

        TM_ILI9341_DrawLine(x - 1, prev_y, x, prev_y, line_color); // Horizontal step
        TM_ILI9341_DrawLine(x, prev_y, x, current_y, line_color); // Vertical step

        // Save the current y-coordinate for the next iteration
        old_y[x] = current_y;
    }
}



void drawMatricesUI() {
    // Clear the measurement area and draw a title and separators
    TM_ILI9341_DrawFilledRectangle(241, 0, 320, 180, ILI9341_COLOR_BLACK);

    // Draw the "Matrices" title and lines
    TM_ILI9341_Puts(245, 5, "Matrices", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_BLACK);
    TM_ILI9341_DrawLine(240, 20, 320, 20, ILI9341_COLOR_GRAY);
    TM_ILI9341_DrawLine(240, 180, 320, 180, ILI9341_COLOR_GRAY);

    // Draw the static labels for Channel 1
    int y_pos = 25;
    TM_ILI9341_Puts(245, y_pos, "CH1:", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Duty:", &TM_Font_7x10, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Vpp:", &TM_Font_7x10, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Avg:", &TM_Font_7x10, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Fq:", &TM_Font_7x10, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
    y_pos += 27;
    TM_ILI9341_DrawLine(240, y_pos, 320, y_pos, ILI9341_COLOR_GRAY);
    // Draw the static labels for Channel 2
    y_pos +=5; // Adjusted y-position to increase the gap
    TM_ILI9341_Puts(245, y_pos, "CH2:", &TM_Font_7x10, ILI9341_COLOR_WHITE, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Duty:", &TM_Font_7x10, ILI9341_COLOR_ORANGE, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Vpp:", &TM_Font_7x10, ILI9341_COLOR_ORANGE, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Avg:", &TM_Font_7x10, ILI9341_COLOR_ORANGE, ILI9341_COLOR_BLACK);
    y_pos += 12;
    TM_ILI9341_Puts(245, y_pos, "Fq:", &TM_Font_7x10, ILI9341_COLOR_ORANGE, ILI9341_COLOR_BLACK);
}


void displayMatricesValues( uint16_t buffer[], uint16_t size, uint8_t adc_rate, uint8_t channel1_active, uint8_t channel2_active) {
    char value_str[15];
    int intPart, fracPart;
    int index1, index2;

    for (int channel = 1; channel <= 2; channel++) {
        if ((channel == 1 && channel1_active) || (channel == 2 && channel2_active)) {
            int offset = channel - 1;
            uint16_t color = (channel == 1) ? ILI9341_COLOR_YELLOW : ILI9341_COLOR_ORANGE;
            int y_pos_start = (channel == 1) ? 25 : (25 + (12 * 4) + 32);

            // Calculate min
            int min_adc = buffer[offset];
            for (int i = 0; i < size / 2; i++) {
                if (buffer[i * 2 + offset] < min_adc)
                    min_adc = buffer[i * 2 + offset];
            }

            // Calculate max
            int max_adc = buffer[offset];
            for (int i = 0; i < size / 2; i++) {
                if (buffer[i * 2 + offset] > max_adc)
                    max_adc = buffer[i * 2 + offset];
            }

            // Calculate average
            int sum = 0;
            for (int i = 0; i < size / 2; i++)
                sum += buffer[i * 2 + offset];
            double avg_adc = (double)sum / (size / 2.0);

            float min_voltage = (float)min_adc * (3.3f / 4095.0f);
            float max_voltage = (float)max_adc * (3.3f / 4095.0f);
            float avg_voltage = (float)avg_adc * (3.3f / 4095.0f);

            // Use the new functions to calculate frequency and duty cycle
            float frequency = osci_freq(buffer, size, channel, max_adc, min_adc, adc_rate, &index1, &index2);
            float duty_cycle = 0.0;
            if (index1 != -1 && index2 != -1) {
                duty_cycle = osci_duty(buffer, size, channel, max_adc, min_adc, index1, index2);
            }

            int y_pos = y_pos_start + 12;

            // Display Duty Cycle
            if (index1 != -1 && index2 != -1) {
            	float_to_str((float)duty_cycle, value_str, 1);
                snprintf(value_str, sizeof(value_str), "%s%%", value_str);
            } else {
                strcpy(value_str, "--%%");
            }
            TM_ILI9341_Puts(275+7, y_pos, "     ", &TM_Font_7x10, ILI9341_COLOR_BLACK, ILI9341_COLOR_BLACK);// clear previous
            TM_ILI9341_Puts(275+7, y_pos, value_str, &TM_Font_7x10, color, ILI9341_COLOR_BLACK);
            y_pos += 12;

            // Display Vpp
            float vpp = max_voltage - min_voltage;
            intPart = (int)vpp;
            fracPart = (int)((vpp - intPart) * 100);
            snprintf(value_str, sizeof(value_str), "%d.%02d V", intPart, fracPart);
            TM_ILI9341_Puts(275, y_pos, value_str, &TM_Font_7x10, color, ILI9341_COLOR_BLACK);
            y_pos += 12;

            // Display Avg Voltage
            intPart = (int)avg_voltage;
            fracPart = (int)((avg_voltage - intPart) * 100);
            snprintf(value_str, sizeof(value_str), "%d.%02d V", intPart, fracPart);
            TM_ILI9341_Puts(275, y_pos, value_str, &TM_Font_7x10, color, ILI9341_COLOR_BLACK);
            y_pos += 12;

            // Display Frequency
            if (frequency > 0) {
            	float_to_str((float)frequency, value_str, 1);
            	snprintf(value_str, sizeof(value_str), "%sHz", value_str);
            } else {
                strcpy(value_str, "-- Hz");
            }
            TM_ILI9341_Puts(275-7, y_pos, "      ", &TM_Font_7x10, ILI9341_COLOR_BLACK, ILI9341_COLOR_BLACK);// clear previous
            TM_ILI9341_Puts(275-7, y_pos, value_str, &TM_Font_7x10, color, ILI9341_COLOR_BLACK);
        }
    }
}

float osci_freq(uint16_t buffer[], uint16_t size, uint8_t channel, int max, int min, uint8_t adc_rate, int *index1, int *index2) {
    *index1 = -1;
    *index2 = -1;
    float frequency;
    float trigger_level = min + (max - min) / 2.0;

    for (int i = 1; i < size / 2; i++) {
        if (buffer[i * 2 + channel - 1] > trigger_level && buffer[(i - 1) * 2 + channel - 1] < trigger_level) {
            *index1 = i;
            break;
        }
    }

    for (int i = *index1 + 1; i < size / 2; i++) {
        if (buffer[i * 2 + channel - 1] > trigger_level && buffer[(i - 1) * 2 + channel - 1] < trigger_level) {
            *index2 = i;
            break;
        }
    }

    if (*index1 == -1 || *index2 == -1)
        return 0;

    frequency = 1000.0 / adc_rate * 40 / (*index2 - *index1);
    return frequency;
}

float osci_duty(uint16_t buffer[], uint16_t size, uint8_t channel, int max, int min, int index1, int index2) {
	float trigger_level = min + (max - min) / 2.0;
    int high_count = 0;

    for (int i = index1; i < index2; i++) {
        if (buffer[i * 2 + channel - 1] >= trigger_level)
            high_count += 1;
    }
    return (float)high_count / (index2 - index1) * 100;
}

void save_waveform_to_nand(uint8_t *buffer) {
    // 1. Define the physical address to write to.
    //    We'll use Zone 0, Block 10, Page 0.
    NAND_ADDRESS save_address;
    save_address.Zone = 0;
    save_address.Block = 10;
    save_address.Page = 0;

    // 2. Erase the entire block first. This is mandatory for NAND flash.
    FMC_NAND_EraseBlock(save_address);

    // 3. Write your 960-byte waveform data to the page.
    //    The function takes a uint8_t pointer, so we must cast our buffer.
    FMC_NAND_WriteSmallPage(buffer, save_address, 1); // Writing 1 page
}

/**
 * @brief Recalls the waveform from the NAND flash.
 */
void recall_waveform_from_nand(uint16_t *buffer) {
    // 1. Define the same address we saved to.
    NAND_ADDRESS recall_address;
    recall_address.Zone = 0;
    recall_address.Block = 10;
    recall_address.Page = 0;
    static uint8_t page_buffer[NAND_PAGE_SIZE];

    // 2. Read one full page (2048 bytes) from the NAND flash.
    //    Our 960 bytes of data will be at the beginning of the received data.
    FMC_NAND_ReadSmallPage(page_buffer, recall_address, 1); // Reading 1 page
    memcpy(buffer, page_buffer, 480 * sizeof(uint16_t));
    // Now, 'read_nand_buffer' contains the recalled waveform.
    // You can proceed to display it on the LCD.
}

void screen_timer(void){ //lcd refresh rate
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);

	TIM_TimeBaseInitTypeDef TIM4_InitStructure;

	TIM4_InitStructure.TIM_Prescaler = 9999;
	TIM4_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM4_InitStructure.TIM_Period = 299;
	TIM4_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM4_InitStructure.TIM_RepetitionCounter = 0;

	TIM_ITConfig(TIM4,TIM_IT_Update,ENABLE);
	TIM_TimeBaseInit(TIM4,&TIM4_InitStructure);

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd =ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}


void dmm(){
	dmmButtonInit();

	drawDMMUI(); // Draw the DMM UI
	DHT22_Init();
	dmm_TIM2_Init();
	oscilloscope_init(dmm_buffer,2);
	adc_timer( MODE_100ms_DIV );
	dht22_interrupt();
	TIM_Cmd(TIM3, ENABLE); // activate timer
	TIM_Cmd(TIM5, ENABLE); // activate timer

	int dmmMode = 8;
	int oldDmmMode = dmmMode;
	char value_char[6];
	char unit_char[2];
	int numMode = 0;
	int dmm_data_mode = 2;

	while (dmmMode != 0){
		dmmMode = dmmTS();
		//read dmm value function ()
		float value;
		value = dmm_value(dmm_data_mode,dmm_buffer,&get_temp,&temp_value);

		if (value < 0){
			if ( oldDmmMode == 4)
				value = 0;// resistant cannot be -ve
			else{
				TM_ILI9341_DrawFilledRectangle(65, 67, 72, 69, ILI9341_COLOR_YELLOW);// display negative sign
				value = -value; //make the display number positive for a better conversion to zero entended string
			}
		}
		else
			TM_ILI9341_DrawFilledRectangle(65, 67, 72, 69, ILI9341_COLOR_BLACK);

		if (value >= 0 && value <= 1 && oldDmmMode == 4)
			GPIO_SetBits(GPIOC, GPIO_Pin_12);
		else
			GPIO_ResetBits(GPIOC, GPIO_Pin_12);


	  // Call the function. It will modify the contents of these variables.
	  displayValue(value, numMode, value_char, unit_char);
	  TM_ILI9341_Puts(75, 60, value_char, &TM_Font_16x26, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
	  TM_ILI9341_Puts(165, 65, unit_char, &TM_Font_11x18, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
	  if (dmmMode != 0 && dmmMode != -1) {
		  if (dmmMode != 6 && dmmMode != 7){
			  oldDmmMode = dmmMode;
			  drawDmmModesButtons(dmmMode);

			  TM_ILI9341_DrawFilledRectangle(180 - 2, 65 - 10, 180 + 20,  65 + 20,  ILI9341_COLOR_BLACK);
			  switch (dmmMode) {
				  case 1:
					  // Temperature button was pressed.
					  dmm_data_mode=1;
					  drawDegreeCSymbol(188, 65, 2, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
					  break;
				  case 2:
					  // Voltage button was pressed.
					  dmm_data_mode=2;
					  TM_ILI9341_Puts(180, 65, "V", &TM_Font_11x18, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
					  break;
				  case 3:
					  // Capacitance button was pressed.
					  dmm_data_mode=3;
					  TM_ILI9341_Puts(180, 65, "F", &TM_Font_11x18, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
					  break;
				  case 4:
					  // Resistance button was pressed.
					  dmm_data_mode=4;
					  drawOmegaSymbol(185, 72, 5, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
					  break;
				  case 5:
					  // Current button was pressed.
					  dmm_data_mode=5;
					  TM_ILI9341_Puts(180, 65, "A", &TM_Font_11x18, ILI9341_COLOR_YELLOW, ILI9341_COLOR_BLACK);
					  break;
				  default:
					  // Do nothing if no button is pressed (dmmTS() returns -1).
					  break;
			  }
		  }
		  else if (dmmMode == 6 || dmmMode == 7){
			  switch (dmmMode) {
			      case 6: // Up button
			          // Increment numMode
			          if (numMode < 5) {
			              numMode++;
			          }
			          break;
			      case 7: // Down button
			          // Decrement numMode
			          if (numMode > -5) {
			              numMode--;
			          }
			          break;
					default:
						  // Do nothing if no button is pressed
						  break;
			  }
		  }
	  }
	}
}

void displayValue(float read_value, int mode, char* converted_value, char* unit_buffer) {
    float converted_val = read_value;
    int dp = 3; // Default decimal points
    char* unit_str = " ";

    switch (mode) {
        case 5:
            converted_val /= 1e9;
            unit_str = "G";
            break;
        case 4:
            converted_val /= 1e6;
            unit_str = "M";
            break;
        case 3:
            converted_val /= 1e3;
            unit_str = "k";
            break;
        case 2:
            dp = 1;
            unit_str = " ";//hundreds
            break;
        case 1:
            dp = 2;
            unit_str = " ";//tens
            break;
        case 0:
            dp = 3;
            unit_str = " ";//ones
            break;
        case -1:
            converted_val *= 10;
            unit_str = "d";
            break;
        case -2:
            converted_val *= 100;
            unit_str = "c";
            break;
        case -3:
            converted_val *= 1e3;
            unit_str = "m";
            break;
        case -4:
            converted_val *= 1e6;
            unit_str = "u";
            break;
        case -5:
            converted_val *= 1e9;
            unit_str = "n";
            break;
        default:
            converted_val = 0.0;
            unit_str = " ";
            break;
    }

    // Check for "Overload" (OL) condition after conversion
    if (converted_val >= 9999.0f) {
        strcpy(converted_value, "   OL");
        strcpy(unit_buffer, " ");
    } else {
        // Copy the unit string into the provided buffer
        strcpy(unit_buffer, unit_str);

        // Format the value string
        floatToStringEXT(converted_value, converted_val, dp);
    }
}

void floatToStringEXT(char* returned_value, float value, int decimalPlaces) {// with zero extend for dmm display purpose
    // Round the value to the specified decimal places
    float multiplier = pow(10, decimalPlaces);
    value = round(value * multiplier) / multiplier;

    if (decimalPlaces == 0) {
        // No decimal point, pad with zeros to 4 digits
        int intValue = (int)round(value);
        snprintf(returned_value, 6, "%04d", intValue);
    } else {
        // With decimal point
        int totalDigits = 4 - decimalPlaces; // digits before decimal point

        // Extract integer and fractional parts
        int intPart = (int)value;
        int fracPart = (int)round((value - intPart) * multiplier);

        // Handle case where rounding causes overflow in fractional part
        if (fracPart >= (int)multiplier) {
            intPart++;
            fracPart = 0;
        }

        // Format with zero padding for integer part
        snprintf(returned_value, 6, "%0*d.%0*d", totalDigits, intPart, decimalPlaces, fracPart);
    }

    // Ensure null termination
    returned_value[5] = '\0';
}

void float_to_str(float value, char* buffer, int decimal_places) {
    int integer_part = (int)value;
    float fractional_part = value - integer_part;

    for (int i = 0; i < decimal_places; i++) {
        fractional_part *= 10;
    }
    int fractional_int = (int)fractional_part;

    snprintf(buffer, 20, "%d.%d", integer_part, fractional_int);
}
